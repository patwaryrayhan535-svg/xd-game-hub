<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Ex Advanced Snake ‚Äî Fixed</title>
    <style>
      :root {
        --bg1: #061826;
        --bg2: #0b3a4b;
        --accent: #00ff99;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(180deg, var(--bg1), var(--bg2));
        color: #eafaf1;
        font-family: system-ui, Arial, sans-serif;
      }
      .wrap {
        width: 100%;
        max-width: 680px;
        padding: 20px;
      }
      .panel {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      .title {
        font-size: 20px;
        font-weight: 700;
      }
      canvas {
        background: #071018;
        border-radius: 10px;
        border: 4px solid rgba(0, 0, 0, 0.3);
        display: block;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      button {
        background: var(--accent);
        border: none;
        padding: 8px 12px;
        border-radius: 8px;
        color: #022;
        cursor: pointer;
        font-weight: 600;
      }
      .small {
        padding: 6px 8px;
        font-size: 14px;
      }
      .info {
        color: #bfead2;
      }
      .scoreboard {
        display: flex;
        gap: 14px;
        align-items: center;
        color: #bfead2;
      }
      .muted {
        color: #92bba3;
        font-size: 13px;
      }
      .footer {
        margin-top: 12px;
        color: #9fbfb0;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="panel">
        <div>
          <div class="title">üêçEx Advanced Snake (Fixed)</div>
          <div class="muted">
            Use Arrow keys or WASD to control. Hit wall or self ‚Üí Game Over.
          </div>
        </div>

        <div class="scoreboard">
          <div>Score: <strong id="score">0</strong></div>
          <div>High: <strong id="high">0</strong></div>
        </div>
      </div>

      <canvas id="c" width="400" height="400"></canvas>

      <div
        style="display: flex; gap: 8px; margin-top: 12px; align-items: center"
      >
        <div class="controls">
          <button id="startBtn" class="small">Start</button>
          <button id="pauseBtn" class="small">Pause</button>
          <button id="resetBtn" class="small">Restart</button>
        </div>

        <div
          style="
            margin-left: auto;
            display: flex;
            gap: 8px;
            align-items: center;
          "
        >
          <label class="muted">Grid:</label>
          <select id="gridSelect" class="small">
            <option value="16">16</option>
            <option value="20" selected>20</option>
            <option value="24">24</option>
          </select>

          <label class="muted">Speed:</label>
          <input id="speedInput" type="range" min="60" max="220" value="120" />
          <span class="muted" id="speedLabel">120ms</span>
        </div>
      </div>

      <div class="footer">
        Tip: If game doesn't start automatically press <strong>Start</strong>.
        Pause with Pause button or press <kbd>P</kbd>.
      </div>
    </div>

    <script>
      (() => {
        // Canvas + context
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");

        // UI elements
        const scoreEl = document.getElementById("score");
        const highEl = document.getElementById("high");
        const startBtn = document.getElementById("startBtn");
        const pauseBtn = document.getElementById("pauseBtn");
        const resetBtn = document.getElementById("resetBtn");
        const gridSelect = document.getElementById("gridSelect");
        const speedInput = document.getElementById("speedInput");
        const speedLabel = document.getElementById("speedLabel");

        // Game state
        let grid = parseInt(gridSelect.value, 10); // number of cells per row
        let box = canvas.width / grid; // cell pixel size
        let snake = []; // array of {x,y}
        let dir = "RIGHT"; // current direction
        let nextDir = null; // queued direction (to prevent reverse)
        let food = null; // food position
        let score = 0;
        let high = parseInt(localStorage.getItem("snake_high") || "0", 10);
        highEl.textContent = high;
        let intervalMs = parseInt(speedInput.value, 10); // ms per step
        speedLabel.textContent = intervalMs + "ms";

        let gameInterval = null;
        let running = false;
        let paused = false;

        // Helpers
        function resetState() {
          grid = parseInt(gridSelect.value, 10);
          box = canvas.width / grid;
          snake = [];
          // start with length 3 centered
          const mid = Math.floor(grid / 2);
          snake.push({ x: mid - 1, y: mid });
          snake.push({ x: mid, y: mid });
          snake.push({ x: mid + 1, y: mid });
          dir = "LEFT"; // start moving left so user can press other keys
          nextDir = null;
          placeFood();
          score = 0;
          scoreEl.textContent = score;
          intervalMs = parseInt(speedInput.value, 10);
          speedLabel.textContent = intervalMs + "ms";
          stopLoop();
          running = false;
          paused = false;
          pauseBtn.textContent = "Pause";
          startBtn.textContent = "Start";
        }

        function placeFood() {
          // place food on a free cell
          let tries = 0;
          while (true) {
            const x = Math.floor(Math.random() * grid);
            const y = Math.floor(Math.random() * grid);
            if (!snake.some((s) => s.x === x && s.y === y)) {
              food = { x, y };
              return;
            }
            if (++tries > 1000) break;
          }
          // fallback (shouldn't happen)
          for (let y = 0; y < grid; y++) {
            for (let x = 0; x < grid; x++) {
              if (!snake.some((s) => s.x === x && s.y === y)) {
                food = { x, y };
                return;
              }
            }
          }
        }

        function draw() {
          // background
          ctx.fillStyle = "#0b1b23";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // checker pattern
          for (let r = 0; r < grid; r++) {
            for (let c = 0; c < grid; c++) {
              ctx.fillStyle = (r + c) % 2 === 0 ? "#072029" : "#062125";
              ctx.fillRect(c * box, r * box, box, box);
            }
          }

          // draw food
          if (food) {
            ctx.fillStyle = "#ff5252";
            roundRect(
              ctx,
              food.x * box + 2,
              food.y * box + 2,
              box - 4,
              box - 4,
              6
            );
            ctx.fill();
          }

          // draw snake segments
          for (let i = 0; i < snake.length; i++) {
            const s = snake[i];
            if (i === 0) ctx.fillStyle = "#00ff99"; // head
            else
              ctx.fillStyle = `rgba(38,166,154, ${
                0.25 + 0.75 * (i / snake.length)
              })`;
            roundRect(
              ctx,
              s.x * box + 1,
              s.y * box + 1,
              box - 2,
              box - 2,
              Math.max(4, box * 0.12)
            );
            ctx.fill();
          }
        }

        function roundRect(ctx, x, y, w, h, r) {
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
        }

        function step() {
          // apply queued direction (but prevent direct reverse)
          if (nextDir) {
            const nd = nextDir;
            if (
              !(nd === "LEFT" && dir === "RIGHT") &&
              !(nd === "RIGHT" && dir === "LEFT") &&
              !(nd === "UP" && dir === "DOWN") &&
              !(nd === "DOWN" && dir === "UP")
            ) {
              dir = nd;
            }
            nextDir = null;
          }

          const head = { ...snake[0] };
          if (dir === "LEFT") head.x -= 1;
          if (dir === "RIGHT") head.x += 1;
          if (dir === "UP") head.y -= 1;
          if (dir === "DOWN") head.y += 1;

          // WALL collision -> game over
          if (head.x < 0 || head.y < 0 || head.x >= grid || head.y >= grid) {
            return gameOver();
          }

          // self collision
          if (snake.some((seg) => seg.x === head.x && seg.y === head.y)) {
            return gameOver();
          }

          // push new head
          snake.unshift(head);

          // eat food?
          if (food && head.x === food.x && head.y === food.y) {
            score += 1;
            scoreEl.textContent = score;
            // speed up gradually (decrease interval)
            if (intervalMs > 40) {
              intervalMs = Math.max(40, Math.round(intervalMs * 0.92)); // accelerate
              restartLoop(); // update interval
              speedLabel.textContent = intervalMs + "ms";
            }
            placeFood();
          } else {
            // remove tail
            snake.pop();
          }

          draw();
        }

        function gameOver() {
          stopLoop();
          running = false;
          // update highscore
          if (score > high) {
            high = score;
            localStorage.setItem("snake_high", String(high));
            highEl.textContent = high;
          }
          // show overlay text
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#fff";
          ctx.font = "24px system-ui";
          ctx.textAlign = "center";
          ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 10);
          ctx.font = "16px system-ui";
          ctx.fillText(
            "Score: " + score,
            canvas.width / 2,
            canvas.height / 2 + 18
          );
          startBtn.textContent = "Start";
        }

        // Loop control
        function startLoop() {
          if (gameInterval) return;
          gameInterval = setInterval(step, intervalMs);
          running = true;
          paused = false;
          startBtn.textContent = "Running";
        }
        function stopLoop() {
          if (gameInterval) {
            clearInterval(gameInterval);
            gameInterval = null;
          }
          running = false;
        }
        function restartLoop() {
          stopLoop();
          // small delay to ensure cleared before re-setup
          gameInterval = setInterval(step, intervalMs);
          running = true;
        }

        // Input handling
        window.addEventListener("keydown", (e) => {
          const k = e.key.toLowerCase();
          if (k === "arrowleft" || k === "a") nextDir = "LEFT";
          else if (k === "arrowup" || k === "w") nextDir = "UP";
          else if (k === "arrowright" || k === "d") nextDir = "RIGHT";
          else if (k === "arrowdown" || k === "s") nextDir = "DOWN";
          else if (k === "p") {
            // pause toggle
            if (!running) return;
            if (paused) {
              restartLoop();
              paused = false;
              pauseBtn.textContent = "Pause";
            } else {
              stopLoop();
              paused = true;
              pauseBtn.textContent = "Resume";
            }
          } else if (k === " ") {
            // space to start if not running
            if (!running) startLoop();
          }
        });

        // Buttons
        startBtn.addEventListener("click", () => {
          if (!running) {
            restartLoop();
          }
        });
        pauseBtn.addEventListener("click", () => {
          if (!running) return;
          if (paused) {
            restartLoop();
            paused = false;
            pauseBtn.textContent = "Pause";
          } else {
            stopLoop();
            paused = true;
            pauseBtn.textContent = "Resume";
          }
        });
        resetBtn.addEventListener("click", () => {
          resetState();
          draw();
        });

        gridSelect.addEventListener("change", () => {
          resetState();
          draw();
        });

        speedInput.addEventListener("input", () => {
          intervalMs = parseInt(speedInput.value, 10);
          speedLabel.textContent = intervalMs + "ms";
          if (running) {
            restartLoop();
          }
        });

        // Initialize
        resetState();
        draw();

        // Auto-start tiny delay to show canvas then start
        setTimeout(() => {
          // do not auto-start if user wants to press start ‚Äî but we start automatically
          restartLoop();
        }, 500);
      })();
    </script>
  </body>
</html>
